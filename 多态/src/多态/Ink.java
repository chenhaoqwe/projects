package 多态;
/**
 * 封装：
 * 1.提高代码的隐私性  不能进行直接的访问和修改  就好像你去银行取钱 你只能通过智能提款机 而不是你进入金钱仓库
 * 2.提高代码的复用性  就是说别人通过某个渠道获得你的方法  不需要重写代码
 * 3.隐藏细节  就是说你不想别人知道你的封装的东西里面具体的细节 你要做的就是我能提供这个功能就对了
 * 继承
 * 1.提高代码的复用性
 * 2.多态的不可缺少因素
 * 3.父类可以有多少个子类  子类却只能有一个父类   就是说 爸爸可以有很多个儿子  儿子只能有一个特定的爸爸
 * 4.父类是子类的子集    就是说爸爸给了儿子100万  儿子拿了这100万 赚到了1000万  就是说子类可以在父类的基础上进行扩展
 * 也就是说需要添加什么东西的时候  继承进行扩展   而父亲老了 就是说得儿子了吧 这个扩展任务得交给儿子
 * 多态：
 * 1.父类的实例化对象的引用指向子类的实例化对象
 * 个人理解：就是说一个水的源头  你在这里挖一条河到某个村子  然后你又要去挖一条河到另外一个村子 为了防止挖掘时候让另外一条
 * 已经修好的村子停水 也不可能去别人那条河再开支流 说不定我这个修的河道就把水占多了呢   引起争吵   
 * 所以我就再从源头开始挖  其实也就是说   我不希望我做的事情打扰到别人 只需要通过源头开始 并且我以后进行维护 
 * 如果这条河道停水了 不会连着其他的河道停水吧    并且我进行维护的时候 也不需要去断了别人村子的河道
 * 互不干扰达不同的村   又完成了运水的事情  到子   同样的功能   最后的目的地不同     就像老师讲的  宠物都是宠物 
 * 都会吃 可是最后吃的不一样 水会流 但是到达村子不同  或者说到了村子 它的用法也不一样了 这些都是多态
 * 
 * 接口
 * 1.接口完全的抽象类                           
 * 2.接口是一套规范
 * 3.接口里面只能是常量 默认被 public static final修饰  一旦赋值无法再被修改
 * 4.接口里面的方法是抽象方法 不能有方法体 并且被默认 public abstract修饰  
 * 5.接口里面的方法和常量都是公开的
 * 6.接口的子类如果不是抽象类  则必须实现接口的方法
 * 7.接口可以进行多继承
 * 抽象类
 * 1.抽象类不是完全的抽象类 
 * 2.抽象类里面可以不存在抽象方法 但抽象方法必须存在抽象类里面
 * 3.抽象类只能单继承
 * 4.抽象类无法实例化
 * 5.抽象类里面的抽象方法必须手动添加public abstract修饰
 * 6.抽象类的子类（非抽象类）必须重写父类的方法
 * 多态三要素：
 * 1.要么存在继承父类  要么继承接口（抽象类）
 * 2.子类(非抽象类)必须重写父类的方法 以及必须实现 接口的方法.  
 * 注意：子类不是抽象类的情况下 因为抽象类无法实例化  既然无法实例化那么就不可能存在对象实例化的引用 就不符合3 
 * 3.父类的实例化对象的引用指向子类的实例化对象
 * @ClassName: Ink
 * @Description: TODO
 * @author chenhao
 * @date 2020-12-28 10:59:02
 */
public interface Ink {
	public abstract void eat();

}
